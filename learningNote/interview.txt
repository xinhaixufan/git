1、类模板中链表使用的注意事项？

2、缓冲区溢出？

3、常见的病毒攻击方式？
缓冲区溢出攻击：是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。
防范方法：
a. 边界检查，确保数据长度不超过缓冲区；
b. 非执行的缓冲区，可以设定堆栈数据段不可执行。

4、http和socket区别？
http是应用层的协议，socket本身不是协议，它的本质是编程接口（API），对TCP/IP协议的封装。

5、哈夫曼编码？
根据字符出现的概率来构造平均长度最短的编码。
哈夫曼树：最优二叉树，也即带权路径最短的树。

6、hash函数的作用？
将任意长度的输入通过散列算法变成固定长度的输出。也就是压缩映射，散列值远小于输入值的空间。
主要用于加密算法：
文件校验、数字签名等。


7、线程与进程的区别？为什么要用多线程？
进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
线程：是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。
一个程序至少一个进程，一个进程至少一个线程。

每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。

    线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。
    进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。

线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化。　

进程线程的区别：
   a.  地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
   b. 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程
    c. 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
    d. 线程是处理器调度的基本单位，但是进程不是。
    e. 两者均可并发执行。

优缺点：
　　线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。
　　进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。
何时使用多进程，何时使用多线程？
对资源的管理和保护要求高，不限制开销和效率时，使用多进程。
要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

8、回调函数

9、智能指针
为了解决动态申请堆内存而没有回收导致的内存泄漏问题
智能指针模板：auto_ptr、unique_ptr、shared_ptr定义了类似指针的对象。在智能指针过期时让它的析构函数删除指向的内存。

用法：auto_ptr<int>ps new string();

auto_ptr:当别的auto_ptr B指向当前auto_ptr A指向的对象时，发生所有权剥夺，原auto_ptr A失效，再次使用auto_ptr A将导致异常。不能与new[]一起使用。
unique_ptr:不允许其他unique_ptr指针指向已经存在的unique_ptr指向的对象，比auto_ptr更安全。可以与new[]一起使用。
shared_ptr:使用引用计数，不剥夺原来智能指针的所有权，引用计数增加到2，降低到0时释放分配的内存。

需要使用多个指针指向一个对象则使用shared_ptr, 不需要使用多个指针指向一个对象则使用unique_ptr。auto_ptr在C++11中摒弃。

10、内联函数
目的是为了提高程序运行进度。
直接将函数代码在函数调用位置展开而非调用函数，节省了调用函数的开支。编译器会根据内联函数的函数体确定是否将其作为内联函数。
和宏定义的区别：宏不能按值传递，

11、函数指针和指针函数
double (*pf) (int):(*f)为函数名，pf即为函数指针，指向函数的入口地址，
有的通用函数需要调用用户自定义的函数，比如排序算法中的排序规则，这个时候就要使用函数指针。

12、new和malloc的区别：new是操作符，malloc是库函数
a. 内存申请位置：new从自由存储区（可以是堆，可以是静态存储区），malloc从堆中申请。
b. 返回类型安全性：new返回的是对象类型的指针，malloc返回的是void*型，需要进行强制类型转换，不是类型安全型的。
c. 申请内存失败时返回值：new抛出异常，malloc返回NULL。
d. 是否需要指定内存大小：new不需要，编译器自行计算；malloc需要显式指定。
_____________________________________________________________________________________________________________________
特征	                       |       new/delete	                       	      |	malloc/free
-------------------------|-----------------------------------------------|--------------------------------------------
分配内存的位置 	        |      自由存储区 	                       	      |	堆
内存分配失败返回值        |	完整类型指针 			      |	void*
内存分配失败返回值        |	默认抛出异常 			      |	返回NULL
分配内存的大小 	        |      由编译器根据类型计算得出 		      |	必须显式指定字节数
处理数组 	有                   |	处理数组的new版本new[] 		      |	需要用户计算数组的大小后进行内存分配
已分配内存的扩充 	        |	无法直观地处理 			      |	使用realloc简单完成
是否相互调用 	        |	可以，看具体的operator new/delete实现    |	不可调用new
分配内存时内存不足       |	客户能够指定处理函数或重新制定分配器     |	无法通过用户代码进行处理
函数重载 		        |	允许 				      |	不允许
构造函数与析构函数       |	调用 				      |	不调用
----------------------------------------------------------------------------------------------------------------------

13、默认参数：函数在调用过程中省略了实参时自动使用的一个值。
极大地提高了函数使用的灵活性.函数原型如下：
int fun(int a, int b=9);
必须从右向左添加默认参数。

14、模板类：不能将模板的成员函数放在独立的实现文件中。
由于模板不是函数，不能单独编译，必须与特定的模板实例化请求一起使用。最简单就是将所有的模板信息放在一个头文件中。

15、sizeof和strlen的区别
sizeof是运算符，strlen是库函数
sizeof计算的是变量占的字节长度，strlen是字符串长度。
sizeof可以用任何类型的参数，strlen只能是char*行，且必须以‘\0’结尾

16、野指针
未初始化的指针变量、指向的内存被释放了没有置NULL、超过了变量作用范围

17、重复delete指针
不能重复delete，delete之后要及时置NULL，置NULL之后第二次delete将不会执行。

18、哈希什么情况下会发生碰撞，怎么样选取哈希的方式能让碰撞几率降低。
哈希值相同的情况下会碰撞；
扩大哈希值的取值空间。
哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。这种方法的基本思想是：首先在元素的关键字k和元素的存储位置p之间建立一个对应关系f，使得p=f(k)，f称为哈希函数。创建哈希表时，把关键字为k的元素直接存入地址为f(k)的单元；以后当查找关键字为k的元素时，再利用哈希函数计算出该元素的存储位置p=f(k)，从而达到按关键字直接存取元素的目的。
   当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 k1≠k2 ，但 H（k1）=H（k2），这种现象称为冲突，此时称k1和k2为同义词。实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。

19、进程间通信方式都有哪些？各自的优缺点是什么？
    1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    4. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    5. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    6. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    7. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
    8. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

20、进程有几种状态，怎么转换的。
一般来说，进程有三个状态，即就绪状态，运行状态，阻塞状态。
运行态：进程占用CPU，并在CPU上运行；
       就绪态：进程已经具备运行条件，但是CPU还没有分配过来；
       阻塞态：进程因等待某件事发生而暂时不能运行；
当然理论上上述三种状态之间转换分为六种情况；
       运行——>就绪：1，主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；2，在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态。
       就绪——>运行：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU
      运行——>阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求
      阻塞——>就绪:进程所等待的事件已经发生，就进入就绪队列

在一些系统中，又增加了一些新状态，如挂起状态，可运行状态，深度睡眠状态，浅度睡眠状态，暂停状态，僵死状态。
可运行状态：运行状态和就绪状态的合并，表示进程正在运行或准备运行，Linux 中使用TASK_RUNNING 宏表示可运行状态。
      浅度睡眠状态：进程正在睡眠（被阻塞），等待资源的到来是唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。Linux 中使用TASK_INTERRUPTIBLE 宏表示此状态。
      深度睡眠状态：其和浅度睡眠基本类似，但不可被其他进程信号或时钟中断唤醒。Linux 中使用TASK_UNINTERRUPTIBLE 宏表示此状态。
      暂停状态：进程暂停执行接受某种处理。Linux 使用TASK_STOPPED 宏表示此状态。
      僵死状态：进程已经结束但未释放进程控制块（PCB），Linux 使用TASK_ZOMBIE 宏表示此状态。
挂起状态：在执行状态的进程通过挂起即可进入就绪状态，如图所示，就绪状态和阻塞状态都分为活动态和静止态。由活动态向静止态转换就是通过挂起实现的。

21、 多线程产生死锁的必要条件
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

22、避免死锁
（1） 互斥条件：可同时访问
（2） 请求与保持条件：进程执行前申请需要的全部资源，在执行过程中不再申请资源。
（3） 不剥夺条件:占有资源的进程若要申请新的进程，必须主动释放已占用资源。
（4） 循环等待条件:层次分配。
银行家算法：
所谓银行家算法，是指在分配资源之前先看清楚，资源分配后是否会导致系统死锁。如果会死锁，则不分配，否则就分配。
按照银行家算法的思想，当进程请求资源时，系统将按如下原则分配系统资源：
(1) 当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程。
(2) 进程可以分期请求资源，当请求的总数不能超过最大需求量。
(3) 当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。
(4) 当系统现有的资源能满足进程尚需资源数时，必须测试系统现存的资源能否满足该进程尚需的最大资源数，若能满足则按当前的申请量分配资源，否则也要推迟分配。

解决死锁的策略
对待死锁的策略主要有：
(1) 死锁预防：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。
(2) 死锁避免：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。
(3) 死锁检测：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。
(4) 死锁解除：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。

死锁的避免：
死锁的预防是通过破坏产生条件来阻止死锁的产生，但这种方法破坏了系统的并行性和并发性。
死锁产生的前三个条件是死锁产生的必要条件，也就是说要产生死锁必须具备的条件，而不是存在这3个条件就一定产生死锁，那么只要在逻辑上回避了第四个条件就可以避免死锁。
避免死锁采用的是允许前三个条件存在，但通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程链，从而避免死锁。该方法支持多个进程的并行执行，为了避免死锁，系统动态的确定是否分配一个资源给请求的进程。方法如下：
1.如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程；
2.如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配；
显然要避免死锁，必须事先知道系统拥有的资源数量及其属性

23、信号量和互斥量
“信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作（大家都在semtake的时候，就阻塞在 哪里）。而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这 个资源。比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的”
也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务 并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进 行操作。在有些情况下两者可以互换。

24.TCP可靠传输方面，主要采用以下4中机制：
    字节编号机制。TCP 数据段以字节为单位对数据段中的“数据”部分进行一一编号，确保每个字节的数据都可以有序传送和接受。
    数据段确认机制。TCP 要求每接受一个数据段都必须由接收端向发送端返回一个确认数据段（可以用一个去人数据段一次确认全面多个数据段），其中的“确认号”表明接收端已正确接受的数据段序号（“确认号”前面的所有数据段，确认号表示将要接收的下一个数据段编号）。
    超时重传机制。在 TCP 中有一个重传定时器（Retransmission Timer， RTT），在发送一个数据段的同时也启动了该定时器。如果在定时器过期之前该数据段还没有被对方确认的话，且定时器停止，然后重传对应序号的数据段。
    选择性确认（Selective ACK， SACK）机制。在 SACK 支持下，仅可以重传缺少部分的数据，而不会重传那些已经正确接受的数据段。

25、为什么要把析构函数定义为虚函数？
new出来的是子类son的对象，采用一个父类father的指针来接收，故在析构的时候，编译器因为只知道这个指针是父类的，所以只将父类部分的内存析构了，而不会去析构子类的内存，就造成了内存泄露。基类析构函数定义为虚拟函数的时候，在子类的对象的首地址开始会有一块基类的虚函数表拷贝，在析构子类对象的时候会删除此虚函数表，此时会调用基类的析构函数，所以此时内存是安全的。

26、为什么虚函数比普通函数慢？
因为虚函数要通过查找虚函数表的方法访问。

27、为什么构造函数不能是虚函数？
构造函数不可以是虚函数的，这个很显然，毕竟虚函数都对应一个虚函数表，虚函数表是存在对象内存空间的，如果构造函数是虚的，就需要一个虚函数表来调用，但是类还没实例化没有内存空间就没有虚函数表，这根本就是个死循环。

28、头文件和源文件
类的声明在头文件，定义者和使用者之间的协议。
.cpp 类的实现#include<*.h>
#ifndef HEADER_H_
#define HEADER_H_
#endif
头文件里面只能有声明，不能有定义。
避免重复定义的错误。

29、extern
extern int i; //声明，不是定义
int i; //声明，也是定义
函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明的。

30、格雷码
i^i>>1

31、结构体和类的区别
实例化的结构体存储在栈内，实例化的类存储在堆中，结构体的效率较高；
结构体没有析构函数；
结构体不可以继承；
结构体的默认成员类型为public，类为private。

32、软件开发模型
a. 瀑布模型：各项活动严格按照线性方式进行，当前活动受上一活动结果的影响。一般适用于需求清晰明了且时间要求宽松的项目，或者规模小、需求简单、功能单一的项目。
b. 原型模型：特点是快速建立可以在计算机上运行的程序，所完成的功能往往是最终产品功能的子集，主要目的是确定客户需求。适用于用户能提出一般性目标但无法给出详细的输入输出需求；开发者不能确定算法的有效性、操作系统的适应性以及人际交互的形式；
c. 螺旋模型：将瀑布模型和原型模型结合起来。特点是风险驱动的，关注风险，进行风险评估后决策是否进行项目。适用于大规模软件项目，需求不明朗风险比较高的项目。
d. 增量模型：融合了瀑布模型的基本成分和原型的迭代特征。把软件产品作为一系列的增量构建来分析、设计、编码、测试和发布，适用于需求逐渐清晰地软件项目。

33、关系数据库范式
1NF,2NF,3NF,4NF,5NF,BCNF。一般情况下满足前三个范式。
第一范式：关系数据库的基本要求，不满足第一范式就不是关系数据库。表中每一列都是不可分割的基本数据项，同一列中不能有多个值。
第二范式：要求每个行可以被唯一地区分。通常将表的一个或多个属性作为行的唯一标识，也就是主键。
第三范式：数据库中的表非主键之间不能有依赖，也就是说一个表中的列不能依赖于另一个表中的非主键列。如果需要进行依赖，一般可以将依赖项独立成为一个新表，被依赖项作为主键。实现第三范式主要是减少数据冗余。

34、数据库事物
事物是指用户在进行数据库操作时的一个操作序列，该操作序列要么全部执行，要么全不执行，所有操作是一个整体，不可分割。
4个特性（ACID）：原子性、一致性、隔离性、持续性。
原子性：该操作序列要么全部执行，要么全不执行，所有操作是一个整体，不可分割。
一致性：指事务执行的结果必须从一个一致性状态转移到另一个一致性状态。
隔离性：并发执行的事务之间不能相互干扰。
持续性：事务一旦提交对数据库的影响是永久的。
